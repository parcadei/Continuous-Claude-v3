#!/usr/bin/env node
/**
 * Pattern Matching Exploit Tests
 *
 * Tests whether approval/cancel patterns can be accidentally triggered.
 *
 * Category C tests from the stress test plan:
 * - C1: Ambiguous Approval
 * - C2: Accidental Cancel
 * - C3: Interview Auto-Complete
 */

/**
 * Simulates the pattern matching from maestro-state-manager.ts
 * Updated to use PatternSet with negative patterns
 */
const PLAN_APPROVAL_PATTERNS = {
  positive: [
    /^(yes|approve|approved|proceed|go\s*ahead|looks\s*good|do\s*it|lgtm)[\s,\.!]*$/i,
    /^yes,?\s*(proceed|go\s*ahead|do\s*it|let'?s?\s*(do|go))[\s\.!]*$/i,
    /\bapprove\s+(the\s+)?plan\b/i,
    /\bplan\s+approved\b/i,
    /\bproceed\s+with\s+(the\s+)?plan\b/i,
  ],
  negative: [
    /\bbut\b/i,
    /\bhowever\b/i,
    /\bwait\b/i,
    /\bhold\s+on\b/i,
    /\?/,
    /\bfirst\b/i,
    /\bbefore\b/i,
    /\bconcern/i,
    /\bquestion/i,
    /\bmaybe\b/i,
    /\bnot\s+yet\b/i,
  ]
};

const CANCEL_PATTERNS = {
  positive: [
    /\bcancel\s+maestro\b/i,
    /\bstop\s+orchestrat/i,
    /\bexit\s+maestro\b/i,
    /\bdisable\s+maestro\b/i,
  ],
  negative: [
    /\bdon'?t\b/i,
    /\bdo\s+not\b/i,
    /\bkeep\b/i,
    /\bwait\b/i,
    /\bnot\s+yet\b/i,
    /\bshould\s+i\b/i,
    /\bif\s+(this|it|we|I)\b/i,
    /\bI'?ll\b/i,
    /\?/,
  ]
};

const INTERVIEW_COMPLETE_PATTERNS = {
  positive: [
    /^interview\s+complete[\s\.!]*$/i,
    /^discovery\s+complete[\s\.!]*$/i,
    /^done\s+(with\s+)?(interview|questions)[\s\.!]*$/i,
    /\bthe\s+interview\s+is\s+complete\b/i,
  ],
  negative: [
    /\?/,
    /\bnot\b/i,
    /\bmore\s+questions\b/i,
    /\bstill\b/i,
    /\bwhen\b/i,
    /\blet\s+me\s+know\b/i,
    /\bshould\b/i,
    /\bsignal\b/i,
  ]
};

function matchesAny(text, patterns) {
  return patterns.some(p => p.test(text));
}

function matchesPattern(text, patternSet) {
  if (Array.isArray(patternSet)) {
    return matchesAny(text, patternSet);
  }
  if (patternSet.negative && matchesAny(text, patternSet.negative)) {
    return false;
  }
  return matchesAny(text, patternSet.positive);
}

/**
 * Test C1: Ambiguous Approval
 *
 * Scenario: User says "Yes, but I have concerns..."
 * Expected: NOT approved (clarification needed)
 * Current: May be APPROVED due to starting with "yes"
 */
function testC1_AmbiguousApproval() {
  console.log('\n━━━ Test C1: Ambiguous Approval ━━━');

  const testCases = [
    { input: 'yes', shouldApprove: true },
    { input: 'Yes, proceed', shouldApprove: true },
    { input: 'approved', shouldApprove: true },
    { input: 'Yes, but I have concerns about the database schema', shouldApprove: false },
    { input: 'Yes, however we should reconsider the approach', shouldApprove: false },
    { input: 'Yes maybe, let me think about it', shouldApprove: false },
    { input: 'Not yet, but yes I see the plan', shouldApprove: false },
  ];

  let passed = 0;
  let failed = 0;

  testCases.forEach(tc => {
    const isApproved = matchesPattern(tc.input, PLAN_APPROVAL_PATTERNS);
    const correct = isApproved === tc.shouldApprove;

    if (correct) {
      passed++;
      console.log(`✅ "${tc.input}" → ${isApproved ? 'APPROVED' : 'NOT APPROVED'} (expected)`);
    } else {
      failed++;
      console.log(`❌ "${tc.input}" → ${isApproved ? 'APPROVED' : 'NOT APPROVED'} (expected ${tc.shouldApprove ? 'APPROVED' : 'NOT APPROVED'})`);
    }
  });

  console.log(`\nSubtotal: ${passed}/${testCases.length} correct`);

  if (failed > 0) {
    console.log('⚠️  Some ambiguous inputs are incorrectly matched');
    console.log('   FIX: Add negative lookahead for "but", "however", "maybe"');
    return { pass: false, reason: `${failed} patterns incorrectly matched` };
  }
  return { pass: true };
}

/**
 * Test C2: Accidental Cancel
 *
 * Scenario: User mentions cancellation in a way that's not a command
 * Expected: NOT cancelled
 * Current: May be CANCELLED due to pattern matching
 */
function testC2_AccidentalCancel() {
  console.log('\n━━━ Test C2: Accidental Cancel ━━━');

  const testCases = [
    { input: 'cancel maestro', shouldCancel: true },
    { input: 'stop orchestrating', shouldCancel: true },
    { input: "Don't cancel maestro yet, I have questions", shouldCancel: false },
    { input: 'Should I cancel maestro or continue?', shouldCancel: false },
    { input: "If this fails, I'll cancel maestro", shouldCancel: false },
    { input: 'exit maestro', shouldCancel: true },
  ];

  let passed = 0;
  let failed = 0;

  testCases.forEach(tc => {
    const isCancelled = matchesPattern(tc.input, CANCEL_PATTERNS);
    const correct = isCancelled === tc.shouldCancel;

    if (correct) {
      passed++;
      console.log(`✅ "${tc.input}" → ${isCancelled ? 'CANCELLED' : 'NOT CANCELLED'} (expected)`);
    } else {
      failed++;
      console.log(`❌ "${tc.input}" → ${isCancelled ? 'CANCELLED' : 'NOT CANCELLED'} (expected ${tc.shouldCancel ? 'CANCELLED' : 'NOT CANCELLED'})`);
    }
  });

  console.log(`\nSubtotal: ${passed}/${testCases.length} correct`);

  if (failed > 0) {
    console.log('⚠️  Some non-commands trigger cancellation');
    console.log('   FIX: Add negative lookbehind for "don\'t", "should I", "if"');
    return { pass: false, reason: `${failed} patterns incorrectly matched` };
  }
  return { pass: true };
}

/**
 * Test C3: Interview Auto-Complete
 *
 * Scenario: User mentions interview/research in a non-completion context
 * Expected: NOT marked complete
 * Current: May be marked COMPLETE
 */
function testC3_InterviewAutoComplete() {
  console.log('\n━━━ Test C3: Interview Auto-Complete ━━━');

  const testCases = [
    { input: 'interview complete', shouldComplete: true },
    { input: 'discovery complete', shouldComplete: true },
    { input: 'done with interview', shouldComplete: true },
    { input: 'I need to research this approach first', shouldComplete: false },
    { input: 'Is the interview complete yet?', shouldComplete: false },
    { input: "Let me know when interview is complete", shouldComplete: false },
    { input: 'The interview complete signal should trigger', shouldComplete: false },
  ];

  let passed = 0;
  let failed = 0;

  testCases.forEach(tc => {
    const isComplete = matchesPattern(tc.input, INTERVIEW_COMPLETE_PATTERNS);
    const correct = isComplete === tc.shouldComplete;

    if (correct) {
      passed++;
      console.log(`✅ "${tc.input}" → ${isComplete ? 'COMPLETE' : 'NOT COMPLETE'} (expected)`);
    } else {
      failed++;
      console.log(`❌ "${tc.input}" → ${isComplete ? 'COMPLETE' : 'NOT COMPLETE'} (expected ${tc.shouldComplete ? 'COMPLETE' : 'NOT COMPLETE'})`);
    }
  });

  console.log(`\nSubtotal: ${passed}/${testCases.length} correct`);

  if (failed > 0) {
    console.log('⚠️  Some questions/contexts trigger completion');
    console.log('   FIX: Require affirmative context or exact match');
    return { pass: false, reason: `${failed} patterns incorrectly matched` };
  }
  return { pass: true };
}

// Run all tests
async function main() {
  console.log('╔════════════════════════════════════════╗');
  console.log('║   Pattern Matching Exploit Tests       ║');
  console.log('╚════════════════════════════════════════╝');

  const results = [];

  results.push({ name: 'C1: Ambiguous Approval', ...testC1_AmbiguousApproval() });
  results.push({ name: 'C2: Accidental Cancel', ...testC2_AccidentalCancel() });
  results.push({ name: 'C3: Interview Auto-Complete', ...testC3_InterviewAutoComplete() });

  // Summary
  console.log('\n╔════════════════════════════════════════╗');
  console.log('║   Test Summary                         ║');
  console.log('╚════════════════════════════════════════╝');

  const passed = results.filter(r => r.pass).length;
  const failed = results.filter(r => !r.pass).length;

  results.forEach(r => {
    const status = r.pass ? '✅' : '❌';
    console.log(`${status} ${r.name}`);
    if (!r.pass) {
      console.log(`   Reason: ${r.reason}`);
    }
  });

  console.log(`\nTotal: ${passed} passed, ${failed} failed`);

  if (failed > 0) {
    console.log('\n━━━ Recommended Fixes ━━━');
    console.log('1. Add negative patterns to reject ambiguous approval');
    console.log('2. Require exact match or command prefix for cancel');
    console.log('3. Add question detection to prevent auto-complete');
  }

  process.exit(failed > 0 ? 1 : 0);
}

main().catch(console.error);
